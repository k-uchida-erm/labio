#!/bin/sh
# Git pre-commit hook: 自動フォーマット・Lint修正・DB変更チェック

# ステージングされたファイルをチェック（フォーマッタ実行前に保存）
STAGED_FILES=$(git diff --cached --name-only)

# フォーマッタ実行前の未ステージング変更を記録（作業中のファイルを保護するため）
# 一時ファイルに保存して、後で比較に使用
BEFORE_UNSTAGED=$(mktemp) || exit 1
AFTER_UNSTAGED=$(mktemp) || exit 1
FORMATTER_CHANGED=$(mktemp) || exit 1
TEMP_TYPES_FILE=$(mktemp) || exit 1
TEMP_FILE=$(mktemp) || exit 1

# すべての一時ファイルをクリーンアップするtrapを設定
# NOTE: シングルクォート内で変数展開させることで、後から定義される変数もまとめてクリーンアップできる
trap 'rm -f "$BEFORE_UNSTAGED" "$AFTER_UNSTAGED" "$FORMATTER_CHANGED" "$TEMP_TYPES_FILE" "$TEMP_FILE"' EXIT

git diff --name-only --diff-filter=ACMR > "$BEFORE_UNSTAGED" 2>/dev/null || true

# すべてのPrettier対応ファイルをフォーマット（型定義生成の前に実行）
echo "🔧 自動フォーマット・Lint修正を実行中..."

# Prettierで自動フォーマット（全ファイル）
echo "  📝 Prettierでフォーマット中..."
npx prettier --write . 2>/dev/null || true

# TypeScript/JavaScriptファイルに対してESLintで自動修正
TS_JS_FILES=$(echo "$STAGED_FILES" | grep -E '\.(ts|tsx|js|jsx)$' || true)
if [ -n "$TS_JS_FILES" ]; then
  echo "  🔍 ESLintで自動修正中..."
  npx eslint . --fix 2>/dev/null || true
fi

# Supabase型定義を毎回生成してステージング（フォーマット後に実行）
# 注意: 型定義はリモート（labio-dev）のスキーマと一致させる必要がある
# ローカル開発では、ローカルSupabaseから生成（開発中の変更を反映）
# CI/CDでは、リモートから生成してコミット（リモートの状態を反映）
if command -v npx >/dev/null 2>&1; then
  echo "🧬 Supabase型定義を生成中..."
  # ローカルSupabaseから型定義を生成（開発中の変更を反映）
  # 出力の最初の行「Connecting to db...」を削除
  # パイプラインの終了ステータス問題を回避するため、一時ファイルを使用
  
  if npx supabase gen types typescript --local > "$TEMP_TYPES_FILE" 2>&1; then
    # 成功した場合のみ、Connecting to db行を削除して出力
    grep -v "^Connecting to db" "$TEMP_TYPES_FILE" > src/types/database.types.ts
    echo "✅ ローカルSupabaseから型定義を生成しました（開発中の変更を反映）"
    rm -f "$TEMP_TYPES_FILE"
  else
    # ローカルが起動していない場合はリモートから生成（フォールバック）
    echo "⚠️  ローカルSupabaseが起動していないため、リモートから型定義を生成します..."
    rm -f "$TEMP_TYPES_FILE"
    if [ -x ".cursor/load-env.sh" ]; then
      bash .cursor/load-env.sh sh -c 'npx supabase gen types typescript --project-id ucsurbtmhabygssexisq > src/types/database.types.ts'
    else
      npx supabase gen types typescript --project-id ucsurbtmhabygssexisq > src/types/database.types.ts
    fi
  fi
  
  # 型定義ファイルをPrettierでフォーマット（生成後に再フォーマット）
  if [ -f src/types/database.types.ts ]; then
    npx prettier --write src/types/database.types.ts 2>/dev/null || true
  fi
fi

# 修正されたファイルをすべてステージング
# Prettier/ESLint/型定義生成で変更されたファイルをすべて検出してステージング
echo "  📦 変更されたファイルをステージング中..."

# フォーマッタ実行後の未ステージング変更を取得
git diff --name-only --diff-filter=ACMR > "$AFTER_UNSTAGED" 2>/dev/null || true

# フォーマッタ実行前後で比較し、新たに変更されたファイルのみを検出
# （元々未ステージングだった作業中のファイルを保護）
comm -13 "$BEFORE_UNSTAGED" "$AFTER_UNSTAGED" > "$FORMATTER_CHANGED" 2>/dev/null || true

# 元々ステージングされていたファイルを再ステージング（フォーマッタで変更された可能性がある）
if [ -n "$STAGED_FILES" ]; then
  echo "$STAGED_FILES" | while IFS= read -r file; do
    if [ -n "$file" ] && [ -f "$file" ]; then
      git add "$file" 2>/dev/null || true
    fi
  done
fi

# フォーマッタ実行前には存在しなかったが、実行後に変更されたファイルをステージング
# （型定義ファイルなど、フォーマッタで生成/変更されたファイル）
if [ -s "$FORMATTER_CHANGED" ]; then
  while IFS= read -r file; do
    if [ -n "$file" ] && [ -f "$file" ]; then
      # 元々ステージングされていたファイル、または型定義ファイルのみをステージング
      # （作業中のファイルを保護）
      if echo "$STAGED_FILES" | grep -Fxq "$file" || [ "$file" = "src/types/database.types.ts" ]; then
        git add "$file" 2>/dev/null || true
      fi
    fi
  done < "$FORMATTER_CHANGED"
fi

# 型定義ファイルを確実にステージング（Prettierでフォーマットされた後）
if [ -f src/types/database.types.ts ]; then
  git add src/types/database.types.ts 2>/dev/null && echo "✅ 型定義ファイルをステージングしました"
fi

echo "✅ 自動フォーマット・Lint修正が完了しました"

# 注意: MCPでDBへの書き込みができないため、型定義の変更は必ずマイグレーションファイルと一緒にコミットされる
# 型定義の変更チェックは不要（マイグレーションファイルなしで型定義が変わることはない）

# 危険なDDL（DROP/TRUNCATEなど）を含むマイグレーションをブロック
MIGRATION_FILES=$(echo "$STAGED_FILES" | grep -E "^supabase/migrations/.*\.sql$" || true)

if [ -n "$MIGRATION_FILES" ]; then
  DANGEROUS_PATTERN='(^|[[:space:]])(DROP[[:space:]]+(TABLE|VIEW|INDEX|SEQUENCE|FUNCTION|TRIGGER|COLUMN|CONSTRAINT)|TRUNCATE[[:space:]]+TABLE)'
  
  # パイプを使わず、一時ファイルでサブシェル問題を回避
  # NOTE: TEMP_FILEは既に最初に定義されているため、ここでは再定義しない

  echo "$MIGRATION_FILES" | while IFS= read -r file; do
    if [ -n "$file" ]; then
      # ステージ済み内容をチェック
      if git show ":$file" | grep -Eqi "$DANGEROUS_PATTERN"; then
        echo "$file" >> "$TEMP_FILE"
      fi
    fi
  done

  # 一時ファイルから結果を読み込む
  if [ -s "$TEMP_FILE" ]; then
    echo "❌ エラー: 危険なDDLが含まれるマイグレーションを検出しました。"
    echo "対象ファイル:"
    while IFS= read -r file; do
      echo "  - $file"
    done < "$TEMP_FILE"
    echo ""
    echo "【対処例】"
    echo "- カラム名変更は RENAME COLUMN に書き換え（DROP/ADD を避ける）"
    echo "- 不要な TRUNCATE/DROP を削除するかデータ退避を検討"
    echo ""
    echo "⚠️  本当に破壊的変更が必要な場合でも、レビューのうえでコメントを残すなど慎重に対応してください。"
    rm -f "$TEMP_FILE"
    exit 1
  fi

  rm -f "$TEMP_FILE"
fi

exit 0